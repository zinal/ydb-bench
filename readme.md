# YDB Bench - Инструмент для нагрузочного тестирования в стиле pgbench

Инструмент для запуска нагрузочных тестов в стиле pgbench для баз данных YDB.

## Установка

### C использованием pipx 

```bash
# Установка c github
pipx install git+https://github.com/senjaster/ydb-bench

# Или установка в режиме разработки
pipx install -e .
```

### Использование pip

```bash
# Активация виртуального окружения
source .venv/bin/activate

# Установка пакета
pip install -e .
```

## Конфигурация

Инструмент поддерживает конфигурацию через переменные окружения с возможностью переопределения через параметры командной строки.

### Переменные окружения

- `YDB_ENDPOINT` - Эндпоинт YDB (например, `grpcs://ydb-host:2135`)
- `YDB_DATABASE` - Путь к базе данных (например, `/Root/database`)
- `YDB_ROOT_CERT` - Путь к файлу корневого сертификата (опционально)
- `YDB_USER` - Имя пользователя для аутентификации (опционально)
- `YDB_PASSWORD` - Пароль для аутентификации (опционально)
- `YDB_PREFIX_PATH` - Имя папки для таблиц (по умолчанию: pgbench)
- `YDB_SERVICE_ACCOUNT_KEY_FILE_CREDENTIALS` - Имя файла, содержащего service account key 
- `YDB_ANONYMOUS_CREDENTIALS` - Анонимное подключение (нужно задать YDB_ANONYMOUS_CREDENTIALS=1)
- `YDB_ACCESS_TOKEN_CREDENTIALS` - Авторизация по токену. Токен должен быть задан непосредственно в переменной окружения (не в файле)

### Пример настройки окружения

```bash
export YDB_ENDPOINT="grpcs://ydb-node-1.ydb-cluster.com:2135"
export YDB_DATABASE="/Root/database"
export YDB_ROOT_CERT="./ca.crt"
export YDB_USER="your_user"
export YDB_PASSWORD="your_password"
```

## Использование

### Глобальные опции командной строки

```
# Использование параметров командной строки (переопределяет переменные окружения)
ydb-bench init \
  --endpoint "grpcs://ydb-host:2135" \
  --database "/Root/database" \
  --ca-file "./ca.crt" \
  --user "root" \
  --password "your_password" \
  --scale 100 \
  --prefix-path pgbench
```

- `endpoint` - Эндпоинт YDB (например, `grpcs://ydb-host:2135`)
- `database` - Путь к базе данных (например, `/Root/database`)
- `ca-file` - Путь к файлу корневого сертификата (опционально)
- `user` - Имя пользователя для аутентификации (опционально)
- `password` - Пароль для аутентификации (опционально)
- `prefix-path` - Имя папки для таблиц (по умолчанию: pgbench)
- `scale` - Коэффициент масштабирования объёма данных

### Инициализация базы данных

Создание таблиц и заполнение тестовыми данными:

```bash
# Использование переменных окружения
ydb-bench --scale 100 init

```

**Параметры:**
- `--scale` / `-s` - Множитель к количеству строк в таблицах (по умолчанию: 100)
- `--prefix-path` - Имя папки для таблиц (по умолчанию: pgbench)

### Запуск нагрузочного теста

Выполнение транзакций tpcb-like из pgbench:

```bash
# Использование переменных окружения
ydb-bench run --jobs 100 --transactions 1000

# Использование параметров командной строки
ydb-bench \
  --endpoint "grpcs://ydb-host:2135" \
  --database "/Root/database" \
  --ca-file "./ca.crt" \
  --user "root" \
  --password "your_password" \
  run \
  --jobs 100 \
  --transactions 1000

# С несколькими клиентскими процессами
ydb-bench run --processes 4 --jobs 25 --transactions 1000

# Использование пользовательского SQL-скрипта
ydb-bench run --jobs 10 --transactions 100 --file custom_script.sql

# Использование нескольких взвешенных скриптов
ydb-bench run --jobs 10 --transactions 100 \
  --file read_heavy.sql@70 \
  --file write_heavy.sql@20 \
  --file mixed.sql@10
```

**Параметры:**
- `--processes` - Количество параллельных клиентских процессов (по умолчанию: 1)
- `--jobs` / `-j` - Количество параллельных задач на процесс (по умолчанию: 1). Каждая задача использует отдельное соединение.
- `--transactions` / `-t` - Количество транзакций, выполняемых каждой задачей (по умолчанию: 100)
- `--preheat` - Количество "разогревающих" транзакций, которые выполняются перед началом подсчета метрик (по умолчанию: 0). Эти транзакции не учитываются в итоговой статистике производительности.
- `--single-session` - Использовать одну постоянную сессию на задачу вместо запроса сессии из пула каждый раз
- `--file` / `-f` - Путь к файлу с SQL-скриптом для выполнения. Можно указать несколько раз с опциональным весом (см. раздел "Взвешенные нагрузки")


## Использование параметров в пользовательских SQL-скриптах

При создании пользовательских SQL-скриптов вы можете использовать следующие параметры, которые автоматически генерируются для каждой транзакции:

### Доступные параметры

- **`$bid`** - (branch ID), генерируется случайное значение в диапазоне от 1 до значения, переданного в  параметр `--scale`
- **`$tid`** - (teller ID), вычисляется как `(bid - 1) * 10 + randint(1, 10)`
- **`$aid`** - (account ID), вычисляется как `(bid - 1) * 100000 + randint(1, 100000)`
- **`$delta`** - Случайное значение от 1 до 1000
- **`$iteration`** - Номер текущей итерации (начиная с 0). Номер итерации уникален только в рамках одного соединения

### table_folder 
Используйте плейсхолдер {table_folder} для имени папки, в которой находятся таблицы. Он будет автоматически заменен на значение параметра --prefix-path (см пример ниже)

### Пример пользовательского скрипта

```sql
-- Простой скрипт обновления баланса счета
UPDATE `{table_folder}/accounts`
SET abalance = abalance + $delta - 100
WHERE aid = $aid;
```

## Взвешенные нагрузки

Инструмент поддерживает запуск нескольких SQL-скриптов с разными весами. При каждой транзакции случайным образом выбирается один из скриптов с учетом его веса.

### Синтаксис

Используйте формат `filename.sql@weight` для указания веса скрипта:

```bash
ydb-bench run --file script1.sql@70 --file script2.sql@30
```

- **Вес по умолчанию**: Если вес не указан, используется значение 1
- **Нормализация**: Веса автоматически нормализуются в проценты

### Примеры

**Пример 1: Разные типы нагрузки с весами**
```bash
# 70% операций чтения, 20% записи, 10% смешанных
ydb-bench run --jobs 10 --transactions 1000 \
  --file workloads/read_only.sql@7 \
  --file workloads/write_only.sql@2 \
  --file workloads/mixed.sql@1
```

**Пример 2: Равномерное распределение (без указания весов)**
```bash
# Каждый скрипт будет выполняться с равной вероятностью (33.3% каждый)
ydb-bench run --jobs 10 --transactions 1000 \
  --file workload1.sql \
  --file workload2.sql \
  --file workload3.sql
```

### Как это работает

1. При запуске все скрипты загружаются и парсятся
2. Веса нормализуются (например, 7+2+1=10, получаем 70%/20%/10%)
3. При каждой транзакции случайным образом выбирается скрипт с учетом весов

## Режимы выполнения

### С использованием пула
Использует пул сессий YDB с автоматической логикой повторных попыток. Подходит для большинства нагрузок.

### Режим одной сессии
Использует одну полученную сессию для всех операций. Может быть быстрее. Экспериментальный режим.

```bash
ydb-bench run --single-session --jobs 10 --transactions 100
```

## Использование нескольких процессов

Когда `--processes` установлен в 1 (по умолчанию), инструмент работает в однопроцессном режиме, используя async/await для параллелизма.

Когда `--processes` больше 1, инструмент использует многопроцессность Python для запуска нескольких процессов параллельно, каждый со своим набором асинхронных задач.


## Количество соединений

Инструмент создает соединения с базой данных на основе двух параметров:

- **Джобы (`--jobs`)**: Количество параллельно выполняющихся джобов внутри каждого процесса. Каждый джоб использует собственное соединение с базой данных.
- **Процессы (`--processes`)**: Количество независимых процессов Python, работающих параллельно. Каждый процесс имеет свой набор задач.

**Формула общего количества соединений:**
```
Общее количество соединений = jobs × processes
```

### Примеры

| Процессы | Джобы  | Общее количество соединений |
|----------|--------|-----------------------------|
| 1        | 10     | 10                          |
| 4        | 25     | 100                         |
| 8        | 50     | 400                         |

### Рекомендации по настройке

1. **Начните с количества джобов**: Сначала увеличивайте `--jobs`, пока использование CPU процессом не достигнет ~80-90%
   - Типичный диапазон: 10-100 джобов на процесс
   - Чем медленнее выполняется транзакция, тем больше джобов может обслуживать один процесс

2. **Масштабируйте процессами**: Как только один процесс насыщен по CPU, увеличивайте `--processes` для увеличения нагрузки соединений
   - Каждый процесс работает независимо со своим собственным циклом событий
   - Распределяет нагрузку между несколькими ядрами CPU

3. **Пример пути масштабирования**:
   ```bash
   # Шаг 1: Найдите оптимальное количество задач на процесс
   ydb-bench run --jobs 10 --transactions 1000   # Мониторьте CPU
   ydb-bench run --jobs 25 --transactions 1000   # Увеличивайте до ~90% CPU
   
   # Шаг 2: Масштабируйте горизонтально с процессами
   ydb-bench run --processes 4 --jobs 25 --transactions 1000  # 100 соединений всего
   ```
   Количество процессов не должно превышать количество ядер CPU.

## Примеры

```bash
# Инициализация с 50 бранчами
ydb-bench init --scale 50

# Запуск нагрузки с 10 задачами, по 500 транзакций каждая
ydb-bench run --jobs 10 --transactions 500

# Запуск нагрузки с 4 клиентскими процессами, 25 задач на процесс
ydb-bench run --process 4 --jobs 25 --transactions 1000

# Запуск с пользовательским скриптом
ydb-bench run --jobs 10 --transactions 100 --file my_script.sql

# Запуск с несколькими взвешенными скриптами
ydb-bench run --jobs 10 --transactions 1000 \
  --file read_heavy.sql@70 \
  --file write_heavy.sql@20 \
  --file analytics.sql@10
```

##  Распределение bid между процессами и джобами
В целом, ydb-bench выполняет транзакции со случайно выбраным $bid из диапазона от единицы до значения параметра --scale. Посольку транзакции выполняется параллельно, возможно возникновени конфликтов и ошибок Transaction Locks Invalidated. Чтобы избежать этого, ydb-bench старается распределить диапазоны значений $bid между разными подключениями так, чтобы они не пересекались и параллельные транзакци не изменяли бы одну и ту же строку в таблице branches. 

Распределение выполняется в два этапа:
- Вначале, каждый из запущеных процессов (параметр `--processes n`) получает свой собственный поддиапазон bid, с которым он работает. Если процесс один, то он получает весь диапазон.
- Далее, каждый процесс внутри себя дополнительно делит выделеный ему диапазон между джобами, которые запускаются внутри него:
    - Если джобов меньше чем значений bid в диапазоне, то каждому джобу выделяется диапазон из нескольких bid. В процессе выполения нагрузки, каждая транзакция случайным образом выбирает branch ID  из диапазона своего джоба. 
    - Если джобов столько же или больше, чем значений в диапазоне, то каждый джоб получает один единственный фиксированный bid и всегда работает только с ним.

### Пример распределения

Представим себе, что ydb-bench запущен с параметрами  `--scale 100, --processes 2, --jobs 4`:

Общий диапазон: [1, 100]

Процесс 0: [1, 50]
  ├─ Джоб 0: → транзакции используют bid от 1 до 13
  └─ Джоб 1: → транзакции используют bid от 14 до 25
  ├─ Джоб 2: → транзакции используют bid от 26 до 38
  └─ Джоб 3: → транзакции используют bid от 39 до 50

Процесс 1: [51, 100]
  ├─ Джоб 0: → транзакции используют bid от 51 до 63
  └─ Джоб 1: → транзакции используют bid от 64 до 75
  ├─ Джоб 2: → транзакции используют bid от 76 до 88
  └─ Джоб 3: → транзакции используют bid от 89 до 100

### Особые случаи
Если общее количество джобов во всех процессах (processes × jobs) больше чем scale, то избежать пересечения по bid между транзакциями не получится и ошибки Transaction Locks Invalidated будут неизбежно возникать. 